package video

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/sendrec/sendrec/internal/database"
)

const maxTranscriptChars = 30000

func formatTranscriptForLLM(segments []TranscriptSegment) string {
	var result string
	for _, seg := range segments {
		totalSeconds := int(seg.Start)
		minutes := totalSeconds / 60
		seconds := totalSeconds % 60
		line := fmt.Sprintf("[%02d:%02d] %s\n", minutes, seconds, seg.Text)
		if len(result)+len(line) > maxTranscriptChars {
			break
		}
		result += line
	}
	return result
}

func processNextSummary(ctx context.Context, db database.DBTX, ai *AIClient) {
	if _, err := db.Exec(ctx,
		`UPDATE videos SET summary_status = 'pending', summary_started_at = NULL, updated_at = now()
		 WHERE summary_status = 'processing'
		   AND (summary_started_at < now() - INTERVAL '10 minutes' OR summary_started_at IS NULL)`,
	); err != nil {
		slog.Error("summary-worker: failed to reset stuck jobs", "error", err)
	}

	var videoID string
	var transcriptJSON []byte
	err := db.QueryRow(ctx,
		`UPDATE videos SET summary_status = 'processing', summary_started_at = now(), updated_at = now()
		 WHERE id = (
		     SELECT id FROM videos
		     WHERE summary_status = 'pending' AND status != 'deleted'
		     ORDER BY updated_at ASC LIMIT 1
		     FOR UPDATE SKIP LOCKED
		 )
		 RETURNING id, transcript_json`,
	).Scan(&videoID, &transcriptJSON)
	if err != nil {
		if !errors.Is(err, pgx.ErrNoRows) {
			slog.Error("summary-worker: failed to claim job", "error", err)
		}
		return
	}

	var segments []TranscriptSegment
	if err := json.Unmarshal(transcriptJSON, &segments); err != nil {
		slog.Error("summary-worker: failed to parse transcript", "video_id", videoID, "error", err)
		markSummaryStatus(ctx, db, videoID, "failed")
		return
	}

	if len(segments) < 2 {
		slog.Warn("summary-worker: skipping video, insufficient segments", "video_id", videoID, "segments", len(segments))
		markSummaryStatus(ctx, db, videoID, "too_short")
		return
	}

	transcript := formatTranscriptForLLM(segments)
	result, err := ai.GenerateSummary(ctx, transcript)
	if err != nil {
		slog.Error("summary-worker: AI generation failed", "video_id", videoID, "error", err)
		markSummaryStatus(ctx, db, videoID, "failed")
		return
	}

	chaptersJSON, err := json.Marshal(result.Chapters)
	if err != nil {
		slog.Error("summary-worker: failed to marshal chapters", "video_id", videoID, "error", err)
		markSummaryStatus(ctx, db, videoID, "failed")
		return
	}

	if _, err := db.Exec(ctx,
		`UPDATE videos SET summary = $1, chapters = $2, summary_status = 'ready', summary_started_at = NULL, updated_at = now()
		 WHERE id = $3`,
		result.Summary, chaptersJSON, videoID,
	); err != nil {
		slog.Error("summary-worker: failed to save summary", "video_id", videoID, "error", err)
		return
	}

	var currentTitle string
	if err := db.QueryRow(ctx, `SELECT title FROM videos WHERE id = $1`, videoID).Scan(&currentTitle); err == nil {
		if isAutoGeneratedTitle(currentTitle) {
			titleTranscript := formatTranscriptForLLM(segments)
			if len(titleTranscript) > 2000 {
				titleTranscript = titleTranscript[:2000]
			}
			if suggestedTitle, err := ai.GenerateTitle(ctx, titleTranscript); err == nil && suggestedTitle != "" {
				_, _ = db.Exec(ctx, `UPDATE videos SET suggested_title = $1, updated_at = now() WHERE id = $2`, suggestedTitle, videoID)
			}
		}
	}
}

func markSummaryStatus(ctx context.Context, db database.DBTX, videoID, status string) {
	if _, err := db.Exec(ctx,
		`UPDATE videos SET summary_status = $1, summary_started_at = NULL, updated_at = now()
		 WHERE id = $2`,
		status, videoID,
	); err != nil {
		slog.Error("summary-worker: failed to update summary status", "video_id", videoID, "status", status, "error", err)
	}
}

func processNextTitleSuggestion(ctx context.Context, db database.DBTX, ai *AIClient) {
	var videoID string
	var transcriptJSON []byte
	var currentTitle string
	err := db.QueryRow(ctx,
		`SELECT id, transcript_json, title FROM videos
		 WHERE summary_status = 'ready'
		   AND suggested_title IS NULL
		   AND transcript_json IS NOT NULL
		   AND status != 'deleted'
		   AND (title LIKE 'Recording %' OR title = 'Untitled Recording' OR title = 'Untitled Video')
		 ORDER BY updated_at ASC LIMIT 1`,
	).Scan(&videoID, &transcriptJSON, &currentTitle)
	if err != nil {
		return
	}

	if !isAutoGeneratedTitle(currentTitle) {
		return
	}

	var segments []TranscriptSegment
	if err := json.Unmarshal(transcriptJSON, &segments); err != nil {
		return
	}

	titleTranscript := formatTranscriptForLLM(segments)
	if len(titleTranscript) > 2000 {
		titleTranscript = titleTranscript[:2000]
	}

	suggestedTitle, err := ai.GenerateTitle(ctx, titleTranscript)
	if err != nil {
		slog.Error("title-suggestion: AI generation failed", "video_id", videoID, "error", err)
		return
	}
	if suggestedTitle == "" {
		return
	}

	if _, err := db.Exec(ctx,
		`UPDATE videos SET suggested_title = $1, updated_at = now() WHERE id = $2`,
		suggestedTitle, videoID,
	); err != nil {
		slog.Error("title-suggestion: failed to save", "video_id", videoID, "error", err)
	} else {
		slog.Info("title-suggestion: suggested title", "video_id", videoID, "suggested_title", suggestedTitle)
	}
}

func StartSummaryWorker(ctx context.Context, db database.DBTX, ai *AIClient, interval time.Duration) {
	if ai == nil {
		return
	}
	go func() {
		slog.Info("summary-worker: started")
		ticker := time.NewTicker(interval)
		defer ticker.Stop()
		for {
			select {
			case <-ctx.Done():
				slog.Info("summary-worker: shutting down")
				return
			case <-ticker.C:
				processNextSummary(ctx, db, ai)
				processNextTitleSuggestion(ctx, db, ai)
			}
		}
	}()
}
